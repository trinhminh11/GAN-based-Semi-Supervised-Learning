from math import sqrt, dist, acos, exp, pi
import torch.nn as nn
import torch


class Sensor:
	pos = ...
	R = ...
	Rmax = ...

	phi = ...

	theta = ...

	def viewingangle2adius(self, phi) -> R:
		self.R = self.Rmax*sqrt(pi/(phi*6))

class Target:
	pos = ...
	v = ...


class House:
	pos = ...

class WareHouse(House):
	pass

class Customer(House):
	pass 


def detect(S: Sensor, T: Target) -> bool:
	if dist(S.pos, T.pos) > S.R:
		return False

	num = T.pos[0]
	deno = dist((0, 0), T.pos)

	phi_T = acos(num/deno)

	return (S.phi - S.theta < phi_T and phi_T < S.phi) 




class Actor(nn.Module):
	def __init__(self, input_dims, h1, h2, output_dims=1) -> None:
		super().__init__()

		self.model = nn.Sequential(
			nn.Linear(input_dims, h1),
			nn.LayerNorm(h1),
			nn.ReLU(),
			nn.Linear(h1, h2),
			nn.LayerNorm(h2),
			nn.ReLU(),
			nn.Linear(h2, output_dims),
			nn.Tanh()
			)
	
	def forward(self, state):
		action = self.model(state)

		action *= pi

		return action
		


class Critic:
	def __init__(self, input_dims, h1, h2, action_space=1, output_dims = 1) -> None:
		super().__init__()

		self.model = nn.Sequential(
			nn.Linear(input_dims, h1),
			nn.LayerNorm(h1),
			nn.ReLU(),
			nn.Linear(h1, h2),
			nn.LayerNorm(h2),
			nn.ReLU(),
		)

		self.action = nn.Linear(action_space, h2)

		self.q = nn.Linear(h2, output_dims)
	
	def forward(self, state, action):
		state_value = self.model(state)

		action_value = self.action(action)

		state_action_value = nn.ReLU(torch.add(state_value, action_value))

		state_action_value = self.q(state_action_value)

		return state_action_value



class Target_Agent:
	def __init__(self, T: Target, input_dims) -> None:
		self.Target = T 
		self.actor = Actor(input_dims, 256, 256)
		self.critic = Critic(input_dims, 256, 256)
	
	def Obs_attention(self, alpha, beta):
		return beta/exp(alpha)
	
	def Sensor_attention(self, S: Sensor):
		R = S.R
		phi = S.phi
		num = self.Target.pos[0]
		deno = dist((0, 0), self.Target.pos)

		phi_T = acos(num/deno)

		dst = dist(self.Target.pos, S.pos)

		A = dst/R
		B = phi - phi_T

		# return a function sush as if A and B increasing => f decreasing and vice versa
		def f(_A, _B):
			pass

		return f(A, B)


class Multi_Agent:
	def __init__(self, agents: list[Target_Agent]) -> None:
		self.agents = agents

	
	def reward_calc(self):
		# calc depends on all Agent Reward = f(agents)
		pass




class Sensor_Agent:
	def __init__(self) -> None:
		pass


class 